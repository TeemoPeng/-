#### HTTP2 与HTTP 1.x 的区别

1. **数据传输格式不一样**
   HTTP2采用的是二进制的传输方式，而HTTP1采用的是文本方式

2. **头部压缩**

   HTTP1会在请求和响应中重复的携带不常改变的、冗余的头部数据，给网络带来额外的负担。

   HTTP2在客户端和服务器端使用首部表来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送，可以理解为只发送差异数据，而不是全部发送，从而减小头部的信息量。

3. **多路复用**

   HTTP1中，如果想并发多个请求，必须使用多个TCP连接，而且浏览器为了控制资源，还会对单个域名有6-8个的TCP连接请求限制。

   在HTTP2中：

   1. 同一个域名下的所有通信都在单个连接上完成。
   2. 单个连接可以承载任意数量的双向数据流。
   3. 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧的首部的流标识可以重新组装



#### HTTP的缓存过程是怎样的？

通常的步骤是这样的：

1. 客户端向服务器端发送请求，请求资源
2. 服务器端响应请求，返回资源，并通过响应头来觉得缓存策略
3. 客户端根据响应头的策略来决定是否缓存资源，假如是，则将响应头与资源缓存下来
4. 在客户端再次请求，且命中资源的时候，此时客户端会去检查上传缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存



#### 什么时候会触发强缓存或者协商缓存？

**强缓存**

强缓存由两个响应头来决定，Expires、Cache-Control

- Expires :  Expires是http1.0提出的一个表示自愿过期时间的header，它描述的是一个绝对时间，由服务器返回，Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效

- Cache-Control：在http1.1版本中新增了Cache-Control，优先级高于Expires，表示的是相对时间，比如：

  Cache-Control: max-age = 314210000

  目前主流的做法是使用Cache-Control控制缓存，除了max-age控制过期时间外，还有一些不得不提：

  - Cache-Control：public ，可以被所有用户缓存，包括终端和CDN等代理服务器
  - Cache-Control：private，只能被终端浏览器缓存，不允许中继缓存服务器进行缓存
  - Cache-Control：no-cache ，先缓存本地，但是命中缓存之后必须与服务器验证缓存的新鲜度才能使用
  - Cache-Control：no-store，不会产生任何缓存

  在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期后会与服务器进行协商。

**协商缓存**